#!/usr/bin/env python

import collections
import os.path
import subprocess
import sys

Dependency = collections.namedtuple('Dependency',
    'name path remote remote_server revision')
TargetDep = collections.namedtuple('TargetDep',
    'dep full_path rev_hash')

def get_rev_hash(rev):
    p = subprocess.Popen(
        ['git', 'rev-parse', rev],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    out, err = p.communicate()
    return out.strip() if not err else None

def get_rev_hash_from_repo(rev, repo):
    rev_hash = None
    if os.path.isdir(repo):
        orig_dir = os.getcwd()
        os.chdir(repo)
        rev_hash = get_rev_hash(rev)
        os.chdir(orig_dir)
    return rev_hash

def find_dep_file(search_up):
    cur_path = os.getcwd()
    file = None
    while not file:
        try:
            file = open(os.path.join(cur_path, '.rept_deps'))
            os.chdir(cur_path)
        except:
            if ((not search_up) or
                (cur_path == os.path.dirname(cur_path))):
                break
            cur_path = os.path.dirname(cur_path)

    return file

def get_dependency_data(rept_deps_file):
    err = None
    contents = None

    try:
        contents = rept_deps_file.read()
    except:
        print('Error: could not read .rept_deps file')
        return None

    try:
        contents = eval(contents, {}, {})
    except:
        print('Error: could not parse .rept_deps file')
        return None

    if type(contents) != dict:
        print('Error: .rept_deps must contain a single dictionary')
        return None

    default_remote = ''
    default_remote_server = ''
    default_revision = ''

    defaults = contents.get('defaults')
    if defaults:
        default_remote = defaults.get('remote', default_remote);
        default_remote_server = defaults.get('remote_server', default_remote_server)
        default_revision = defaults.get('revision', default_revision)

    if 'dependencies' not in contents.keys():
        print('Error: .rept_deps does not contain "dependencies" list')
        return None

    dep_list = contents['dependencies']
    if (type(dep_list) != list):
        print('Error: "dependencies" is not a list')
        return None

    dependencies = []

    idx = 0
    for dep in dep_list:
        if (type(dep) != dict):
            print('Error: dependency {0} is not a dictionary'.format(idx))
            return None

        name = dep.get('name')
        path = dep.get('path')

        if not name:
            print('Error: dependency {0} requires a name'.format(idx))
            return None

        if not path:
            print('Error: dependency {0} requires a path'.format(idx))
            return None

        remote = dep.get('remote', default_remote)
        remote_server = dep.get('remote_server', default_remote_server)
        revision = dep.get('revision', default_revision)

        if not remote:
            print('Error: dependency {0} requires a remote'.format(idx))
            return None

        if not remote_server:
            print('Error: dependency {0} requires a remote server'.format(idx))
            return None

        if not revision:
            print('Error: dependency {0} requires a revision'.format(idx))
            return None

        dependencies.append(
            Dependency(name, path, remote, remote_server, revision))

        idx += 1

    return dependencies

def check_subdeps(dep_chain_so_far, repo_name, repo_full_path, targets):
    new_dep_chain = dep_chain_so_far + (repo_full_path,)

    if not os.path.isdir(repo_full_path):
        return (('Missing repo: {0}'.format(dep.name), new_dep_chain),)

    if repo_full_path in dep_chain_so_far:
        return (('Circular reference detected', new_dep_chain),)

    failures = ()
    orig_dir = os.getcwd()
    os.chdir(repo_full_path)
    rept_deps_file = find_dep_file(False)
    if not rept_deps_file:
        os.chdir(orig_dir)
        return ()

    dependencies = get_dependency_data(rept_deps_file)
    rept_deps_file.close()

    if dependencies == None:
        os.chdir(orig_dir)
        return (('Bad .rept_deps file', new_dep_chain),)

    for dep in dependencies:
        cur_repo_path = os.path.abspath(dep.path)
        target_for_dep = targets.get(cur_repo_path)
        if target_for_dep:
            dep_hash = get_rev_hash_from_repo(dep.revision, cur_repo_path)
            if not dep_hash:
                failures += (
                    (['Bad revision specified: {0}'.format(dep.revision),
                      'for repo: {0}'.format(dep.name)],
                    new_dep_chain),)
            elif dep_hash != target_for_dep.rev_hash:
                failures += (
                    (['Inconsistent dependency for {0}:'.format(dep.name),
                      'specified: {0} ({1})'.format(dep.revision, dep_hash),
                      'required: {0} ({1})'.format(
                        target_for_dep.dep.revision, target_for_dep.rev_hash)],
                    new_dep_chain),)
        else:
            failures += check_subdeps(
                new_dep_chain, dep.name, cur_repo_path, targets)

    os.chdir(orig_dir)
    return failures

def check_dep_consistency(dependencies):
    start_dir = os.getcwd()

    failures = ()
    dep_chain_so_far = (start_dir,)

    target_list = []
    target_dict = {}
    for dep in dependencies:
        full_path = os.path.abspath(dep.path)
        if os.path.isdir(full_path):
            target_rev_hash = get_rev_hash_from_repo(dep.revision, full_path)
            if target_rev_hash:
                target_dep = TargetDep(dep, full_path, target_rev_hash)
                target_list.append(target_dep)
                target_dict[full_path] = target_dep
            else:
                failures += (
                    ('Bad revision for {0}: {1}'.format(dep.name, dep.revision),
                    dep_chain_so_far),)
        else:
            failures += (
                ('Missing repo: {0}'.format(dep.name), dep_chain_so_far),)

    for target in target_list:
        failures += check_subdeps(
            dep_chain_so_far, dep.name, target.full_path, target_dict)

    if failures:
        for failure in failures:
            dep_chain = [os.path.basename(dirname) for dirname in failure[1]]
            if (type(failure[0]) == str):
                print(failure[0])
            else:
                print(failure[0][0])
                for msg in failure[0][1:]:
                    print('  ' + msg)
            print('  Detected in: ' + dep_chain[-1])
            for dep in reversed(dep_chain[:-1]):
                print('    included by: ' + dep)

def fetch(dependencies):
    err_list = []
    start_dir = os.getcwd()

    # make sure we *can* clone
    for dep in dependencies:
        print('fetching ' + dep.name + '...')
        os.chdir(start_dir)

        if not os.path.exists(dep.path):
            err_list.append(
                'cannot fetch "{0}": '
                'the path does not exist'.format(dep.path))
            continue

        os.chdir(dep.path)

        # Got a .git dir? Do a fetch.
        if os.path.isdir('.git'):
            ret = subprocess.call(['git', 'fetch', dep.remote])
            if (ret):
                err_list.append(
                    'cannot fetch "{0}": '
                    'fetch failed'.format(dep.path))
        else:
            err_list.append(
                'cannot fetch "{0}": '
                'no ".git" directory'.format(dep.path))

    if err_list:
        for err in err_list:
            print('Error: ' + err)

    os.chdir(start_dir)

def sync(dependencies):
    err_list = []
    start_dir = os.getcwd()

    # make sure we *can* clone
    for dep in dependencies:
        print('syncing ' + dep.name + '...')
        os.chdir(start_dir)
        if (os.path.isfile(dep.path)):
            err_list.append(
                'cannot sync "{0}": '
                'a file with the same name exists'.format(dep.path))
            continue

        if not os.path.exists(dep.path):
            os.makedirs(dep.path)

        os.chdir(dep.path)

        if os.path.isfile('.git'):
            err_list.append(
                'cannot sync "{0}": '
                'a ".git" file exists in the directory'.format(dep.path))
            continue

        # Already a .git dir? Do a fetch.
        if (os.path.isdir('.git')):
            ret = subprocess.call(['git', 'fetch', dep.remote])
            if (ret):
                err_list.append(
                    'cannot sync "{0}": '
                    'fetch failed'.format(dep.path))
        # No .git dir. Do a clone.
        else:
            full_remote_repo_name = dep.remote_server + dep.name
            ret = subprocess.call(
                ['git', 'clone', '-o', dep.remote, full_remote_repo_name, '.'])
            if (ret):
                err_list.append(
                    'cannot sync "{0}": '
                    'fetch failed'.format(dep.path))
            continue

    if err_list:
        for err in err_list:
            print('Error: ' + err)

    os.chdir(start_dir)

def main(argv):

    if len(argv) == 0:
        pass

    dependencies = None

    rept_deps_file = find_dep_file(True)
    if rept_deps_file:
        dependencies = get_dependency_data(rept_deps_file)
        rept_deps_file.close()
    else:
        print('Error: could not find .rept_deps file')

    if not dependencies:
        return

    if argv[0] == 'sync':
        sync(dependencies)
    elif argv[0] == 'fetch':
        fetch(dependencies)
    elif argv[0] == 'chk-deps':
        check_dep_consistency(dependencies)
    else:
        print('unknown command: {0}'.format(argv[0]))

if __name__ == "__main__":
    main(sys.argv[1:])
