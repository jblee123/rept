#!/usr/bin/env python

import ast
import collections
import getopt
import os
import subprocess
import sys

Dependency = collections.namedtuple('Dependency',
    'name path remote remote_server revision')
LocalConfig = collections.namedtuple('LocalConfig',
    'remote')

class DoInExistingDir(object):
    def __init__(self, dir):
        self.old_dir = os.getcwd()
        self.new_dir = dir

    def __enter__(self):
        try:
            os.chdir(self.new_dir)
            return self
        except:
            return None

    def __exit__(self, type, value, traceback):
        os.chdir(self.old_dir)
        return isinstance(value, OSError)

################################################################################
# General util funcs
################################################################################

def printerr(s):
    print(s, file=sys.stderr)

def print_unknown_arg(param):
    printerr('error: unknown argument \'{0}\''.format(param))

def print_std_err(err):
    if (type(err) == str):
        printerr(err)
    else:
        printerr(err[0])
        for msg in err[1:]:
            printerr('  ' + msg)

def print_std_err_list(errs):
    for err in errs:
        print_std_err(err)

def parse_args(args, short_opts, long_opts=[], usage_fn=None):
    try:
        return getopt.getopt(args, short_opts, long_opts)
    except getopt.GetoptError as e:
        printerr('error: ' + e.msg)
        if usage_fn:
            usage_fn()
        sys.exit(1)

def gen_bad_revision_err_str(dep_name, dep_revision, rev_hash_err):
    return ['Bad revision specified: {0}'.format(dep_revision),
            'for repo: {0}'.format(dep_name),
            rev_hash_err]

def exec_proc(cmd):
    p = subprocess.Popen(
        cmd,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    out, err = p.communicate()
    out = str(out,'utf-8').strip()
    err = str(err,'utf-8').strip()
    return p.returncode, out, err

################################################################################
# git util funcs
################################################################################

def get_rev_hash(rev):
    ret, out, err = exec_proc(['git', 'rev-parse', rev])
    return out if not ret else None

def get_rev_hash_from_repo(rev, repo_dir):
    rev_hash = None
    err = ''
    with DoInExistingDir(repo_dir) as ctx:
        if ctx:
            rev_hash = get_rev_hash(rev)
            if not rev_hash:
                err = 'could not get revision from the repo'
        else:
            err = 'could not enter the repo'
    return (rev_hash, err)

def get_branch_exists(branch_name):
    ret, out, err = exec_proc(['git', 'rev-parse', '--verify', branch_name])
    return ret == 0

def is_current_branch(branch_name):
    ret, out, err = exec_proc(['git', 'branch'])
    if ret:
        return False

    branches = [branch.strip() for branch in out.split(os.linesep)]
    branch = [branch[2:] for branch in branches if branch.startswith('* ')]
    return branch[0] == branch_name if branch else False

def get_any_remote_branch_exists(branch_name):
    ret, out, err = exec_proc(['git', 'branch', '-a'])
    if ret:
        return []

    branches = out.split()
    return [branch for branch in branches if
        branch.startswith('remotes/') and branch.endswith('/' + branch_name)]

def is_branch_merged(branch_name):
    ret, out, err = exec_proc(['git', 'branch', '--merged'])
    if ret:
        return False

    branches = out.split()
    return branch_name in branches

def get_remotes():
    ret, out, err = exec_proc(['git', 'remote'])
    if ret:
        return []

    return [remote.strip() for remote in out.split(os.linesep)]

def is_clean_working_directory():
    ret, out, err = exec_proc(['git', 'status', '--porcelain'])
    if ret:
        return False

    return out == ''

def get_file_contents(rev, filename):
    spec = '{0}:{1}'.format(rev, filename)
    ret, out, err = exec_proc(['git', 'show', spec])
    return out if not ret else None

################################################################################
# dependency and config funcs
################################################################################

def move_to_repo_dir_or_die():
    while True:
        if os.path.isdir('.git'):
            break
        else:
            cur_dir = os.getcwd()
            parent_dir = os.path.dirname(cur_dir)
            if cur_dir == parent_dir:
                sys.exit('error: no git repo found')
            os.chdir(parent_dir)

def open_rept_dep_file():
    try:
        return open('.rept_deps')
    except:
        return None

def open_rept_local_file():
    try:
        return open('.rept_local')
    except:
        return None

def parse_local_data(rept_local_str):
    err = None
    contents = None

    try:
        # Use literal_eval() for safety since we're eval'ing untrusted code.
        contents = ast.literal_eval(rept_local_str)
    except SyntaxError as e:
        err = 'syntax error at line {0}, offset {1}'.format(e.lineno, e.offset)
        return (None, err)
    except ValueError:
        err = 'illegal value used. (Do you have a function call in the file?)'
        return (None, err)
    except:
        err = 'unknown parse error'
        return (None, err)

    if type(contents) != dict:
        err = 'must contain a single dictionary'
        return (None, err)

    remote = contents.get('remote', None)
    if remote != None and type(remote) != str:
        err = '"remote" must be a string'
        return (None, err)

    local_config = LocalConfig(remote)

    return (local_config, err)

def get_local_config_from_file(rept_local_file):
    contents = None

    if rept_local_file:
        try:
            contents = rept_local_file.read()
        except:
            return (None, 'could not read the .rept_local file')

        return parse_local_data(contents)
    else:
        local_config = LocalConfig(None)
        return (local_config, None)

def parse_dependency_data(rept_deps_str):
    err = None
    contents = None

    try:
        # Use literal_eval() for safety since we're eval'ing untrusted code.
        contents = ast.literal_eval(rept_deps_str)
    except SyntaxError as e:
        err = 'syntax error at line {0}, offset {1}'.format(e.lineno, e.offset)
        return (None, err)
    except ValueError:
        err = 'illegal value used. (Do you have a function call in the file?)'
        return (None, err)
    except:
        err = 'unknown parse error'
        return (None, err)

    if type(contents) != dict:
        err = 'must contain a single dictionary'
        return (None, err)

    def_remote = ''
    def_remote_server = ''
    def_revision = ''

    defaults = contents.get('defaults')
    if defaults:
        def_remote = defaults.get('remote', def_remote);
        def_remote_server = defaults.get('remote_server', def_remote_server)
        def_revision = defaults.get('revision', def_revision)

    if 'dependencies' not in contents.keys():
        err = '"dependencies" list not found'
        return (None, err)

    dep_list = contents['dependencies']
    if (type(dep_list) != list):
        err = '"dependencies" is not a list'
        return (None, err)

    dependencies = []

    idx = 0
    for dep in dep_list:
        if (type(dep) != dict):
            err = 'dependency {0} is not a dictionary'.format(idx)
            return (None, err)

        name = dep.get('name')
        path = dep.get('path')

        if not name:
            err = 'dependency {0} requires a name'.format(idx)
            return (None, err)

        if not path:
            err = 'dependency {0} requires a path'.format(idx)
            return (None, err)

        remote = dep.get('remote', def_remote)
        remote_server = dep.get('remote_server', def_remote_server)
        revision = dep.get('revision', def_revision)

        if not remote:
            err = 'dependency {0} requires a remote'.format(idx)
            return (None, err)

        if not remote_server:
            err = 'dependency {0} requires a remote server'.format(idx)
            return (None, err)

        if not revision:
            err = 'dependency {0} requires a revision'.format(idx)
            return (None, err)

        dependencies.append(
            Dependency(name, path, remote, remote_server, revision))

        idx += 1

    return (dependencies, err)

def get_dependency_data_from_file(rept_deps_file):
    contents = None

    try:
        contents = rept_deps_file.read()
    except:
        return (None, 'could not read the .rept_deps file')

    return parse_dependency_data(contents)

def get_dependency_data_or_die(rept_deps_file):
    dependencies, err = get_dependency_data_from_file(rept_deps_file)
    if err:
        sys.exit('error: could not load .rept_deps file: ' + err)
    return dependencies

def get_local_config_or_die(rept_local_file):
    local_config, err = get_local_config_from_file(rept_local_file)
    if not local_config:
        sys.exit('error: could not load .rept_local file: ' + err)

    remotes = get_remotes()
    if not remotes:
        sys.exit('error: no remotes detected in this repo')

    remote = local_config.remote
    if remote and (remote not in remotes):
        sys.exit('error: specified remote is not in this repo')

    if not remote:
        if len(remotes) == 1:
            remote = remotes[0]
        else:
            sys.exit('error: multiple remotes detected. specify in .rept_local file')

    local_config = LocalConfig(remote)

    return local_config

################################################################################
# switch cmd funcs
################################################################################

SwitchArgs = collections.namedtuple('SwitchArgs',
    'feature_name create_branches')

SwitchPoint = collections.namedtuple('SwitchPoint',
    'dep target_rev no_action_msg')

def get_switch_point(dep, local_config, switch_args):

    target_rev = None
    remote_target_rev = None
    no_action_msg = None
    remote = dep.remote if dep else local_config.remote
    remote_branch = remote + '/' + switch_args.feature_name

    # Nothing to do if we're already on the correct branch.
    if is_current_branch(switch_args.feature_name):
        no_action_msg = 'already on feature branch'
    # The branch exists and we're not on it, so that's where we need to go.
    elif get_branch_exists(switch_args.feature_name):
        target_rev = switch_args.feature_name
    # The branch does exist locally. How about remotely?
    elif get_branch_exists(remote_branch):
        if switch_args.create_branches:
            # Just set the target_rev to the not-yet-existing local branch, and
            # git's default behavior will create the local branch to track the
            # remote branch that we know exists.
            target_rev = switch_args.feature_name
            remote_target_rev = remote_branch
        else:
            target_rev = remote_branch
    # The branch doesn't exist. If we're in a dependency, we need to go to its
    # specified revision.
    elif dep:
        if get_rev_hash(dep.revision):
            target_rev = dep.revision
        else:
            return (
                None,
                'repo {0} missing both feature branch and dependent revision'.
                    format(dep.name))
    # The branch doesn't exist, and we're not in a dependency, so we must be in
    # the base repo. Stay on the current commit
    else:
        if switch_args.feature_name:
            no_action_msg = 'feature branch not present'
        else:
            no_action_msg = 'no feature branch provided'

    # If we're creating branches, then target_rev may be a local branch that
    # doesn't exist yet. In this case, the remote branch from which we'll create
    # the new branch is stored in remote_target_rev, so that's the one we'll
    # need to test againt in the next step to see if we're really changing
    # commits when we do the checkout.
    existing_target_rev = remote_target_rev or target_rev

    # We know where we need to go. If we're actually changing commits, then the
    # working directory had better be clean so we don't accidentally try to
    # do a checkout that might be destructive.
    if (target_rev and
        get_rev_hash(existing_target_rev) != get_rev_hash('HEAD') and
        not is_clean_working_directory()):
        return (None, 'working directory is not clean for repo {0}'.format(dep.name))

    switch_point = SwitchPoint(dep, target_rev, no_action_msg)

    return (switch_point, None)

def print_switch_usage():
    printerr('usage: rept switch [-b] [<feature-name>]')

def cmd_switch(dependencies, local_config, args):
    parsed_args = parse_args(args, 'b', usage_fn=print_switch_usage)

    if len(parsed_args[1]) > 1:
        print_unknown_arg(parsed_args[1][1])
        print_switch_usage()
        sys.exit(1)

    create_branches = False
    for opt, optarg in parsed_args[0]:
        if opt == '-b': create_branches = True

    feature_name = parsed_args[1][0] if len(parsed_args[1]) else ''

    switch_args = SwitchArgs(feature_name, create_branches)

    errs = []

    switch_points = []
    ret = get_switch_point(None, local_config, switch_args)
    switch_points.append(ret[0])
    if ret[1]:
        errs.append(ret[1])

    for dep in dependencies:
        repo_path = os.path.abspath(dep.path)
        with DoInExistingDir(repo_path) as ctx:
            if ctx:
                ret = get_switch_point(dep, local_config, switch_args)
                switch_points.append(ret[0])
                if (ret[1]):
                    errs.append(ret[1])
            else:
                errs.append('Missing repo: {0}'.format(dep.path))

    if errs:
        print_std_err_list(errs)
        sys.exit(1)

    def do_switch_checkout(rev, dep_path):
        ret = subprocess.call(['git', 'checkout', '-q', rev])
        if ret:
            repo_part = 'repo: {0}'.format(dep_path) if dep_path else 'this repo'
            errs.append(
                'cannot check out rev {0} for {1}'.format(rev, repo_part))

    for sp in switch_points:
        repo_name = sp.dep.name if sp.dep else 'this repo'
        if sp.target_rev:
            print('checking out {0} on {1}...'.format(sp.target_rev, repo_name))
            if sp.dep:
                repo_path = os.path.abspath(sp.dep.path)
                with DoInExistingDir(repo_path) as ctx:
                    if ctx:
                        do_switch_checkout(sp.target_rev, sp.dep.path)
                    else:
                        errs.append(
                            'cannot enter repo at {0} for checkout'.format(sp.dep.path))
            else:
                do_switch_checkout(sp.target_rev, None)
        else:
            print('skipping checkout in {0}: {1}'.format(repo_name, sp.no_action_msg))

    if errs:
        print_std_err_list(errs)
        sys.exit(1)

################################################################################
# feature cmd funcs
################################################################################

FeatureArgs = collections.namedtuple('FeatureArgs',
    'name delete force push push_only')

FeatureBranchState = collections.namedtuple('FeatureBranchState',
    'exists is_current has_remote remote_is_current is_merged')

def can_create_feature_branch(branch_name, remote_name, dep_name, errs):
    if dep_name:
        err_prefix = 'dependency {0}'.format(dep_name)
    else:
        err_prefix = 'this repo'

    remote_branch_name = remote_name + '/' + branch_name
    if get_branch_exists(branch_name):
        errs.append(
            '{0} already contains a local branch: {1}'.
            format(err_prefix, branch_name))
        return

    if dep_name:
        if get_branch_exists(remote_branch_name):
            errs.append(
                '{0} already contains a remote branch: {1}'.
                format(err_prefix, remote_branch_name))
    else:
        remotes = get_any_remote_branch_exists(branch_name)
        if remotes:
            len_remotes_prefix = len('remotes/')
            remotes = [remote[len_remotes_prefix:] for remote in remotes]
            if len(remotes) == 1:
                errs.append(
                    '{0} already contains a remote branch: {1}'.
                    format(err_prefix, remotes[0]))
            else:
                errs2 = [
                    '{0} already contains remote branches:'.
                    format(err_prefix)]
                errs2 += remotes
                errs.append(errs2)

def create_feature(dependencies, feat_args):
    errs = []

    can_create_feature_branch(feat_args.name, '', '', errs)

    for dep in dependencies:
        repo_path = os.path.abspath(dep.path)
        with DoInExistingDir(repo_path) as ctx:
            if ctx:
                can_create_feature_branch(
                    feat_args.name, dep.remote, dep.name, errs)
            else:
                errs.append('Missing repo: {0}'.format(repo_name))
        dep_hash, hash_err = get_rev_hash_from_repo(
            dep.revision, repo_path)
        if not dep_hash:
            errs.append(gen_bad_revision_err_str(
                dep.name, dep.revision, hash_err))

    if errs:
        print_std_err_list(errs)
        sys.exit(1)

    created_branches = 0

    ret = subprocess.call(['git', 'branch', '-q', feat_args.name])
    if (not ret):
        created_branches += 1
    else:
        errs.append(
            'cannot create branch "{0}" in this repo'.format(feat_args.name))

    for dep in dependencies:
        repo_path = os.path.abspath(dep.path)
        with DoInExistingDir(repo_path) as ctx:
            if ctx:
                ret = subprocess.call(
                    ['git', 'branch', '-q', feat_args.name, dep.revision])
                if (not ret):
                    created_branches += 1
                else:
                    errs.append(
                        'cannot create branch "{0}": '
                        'in repo {1}'.format(feat_args.name, dep.name))
            else:
                errs.append('Missing repo: {0}'.format(dep.path))

    print('created {0}/{1} branches'.
        format(created_branches, len(dependencies) + 1))

    if errs:
        print_std_err_list(errs)
        sys.exit(1)

def get_feature_branch_state(branch_name, remote_name):

    remote_branch_name = remote_name + '/' + branch_name

    exists = get_branch_exists(branch_name)
    is_current = is_current_branch(branch_name)
    has_remote = get_branch_exists(remote_branch_name)
    remote_is_current = is_current_branch(remote_branch_name)
    is_merged = is_branch_merged(branch_name)

    return FeatureBranchState(
        exists, is_current, has_remote, remote_is_current, is_merged)

def delete_feature_branch(dep, del_cmd, fail_list, errs):
    success = False
    if not dep:
        ret = subprocess.call(del_cmd)
        if (not ret):
            success = True
        else:
            fail_list.append('this repo')
    else:
        repo_path = os.path.abspath(dep.path)
        with DoInExistingDir(repo_path) as ctx:
            if ctx:
                ret = subprocess.call(del_cmd)
                if (not ret):
                    success = True
                else:
                    fail_list.append('repo {0}'.format(dep.name))
            else:
                errs.append('Missing repo: {0}'.format(dep.path))

    return success

def delete_feature(dependencies, local_config, feat_args):
    errs = []
    branch_states = []

    state = get_feature_branch_state(feat_args.name, local_config.remote)
    branch_states.append((None, state))

    for dep in dependencies:
        repo_path = os.path.abspath(dep.path)
        with DoInExistingDir(repo_path) as ctx:
            if ctx:
                state = get_feature_branch_state(feat_args.name, dep.remote)
                branch_states.append((dep, state))
            else:
                errs.append('Missing repo: {0}'.format(dep.path))

    if errs:
        print_std_err_list(errs)
        sys.exit(1)

    exists = [state for state in branch_states if state[1].exists]
    are_current = [state for state in branch_states if state[1].is_current]
    has_remote = [state for state in branch_states if state[1].has_remote]
    remotes_are_current = [
        state for state in branch_states if state[1].remote_is_current]
    unmerged = [state for state in branch_states if not state[1].is_merged]

    def print_bad_repos(branch_states):
        for dep, state in branch_states:
            printerr('  - {0}'.format(dep.name if dep else 'this repo'))

    if are_current and not feat_args.push_only:
        printerr('error: cannot delete branches checked out in repos:')
        print_bad_repos(are_current)
        sys.exit(1)

    if remotes_are_current and (feat_args.push or feat_args.push_only):
        printerr('error: cannot delete remote branches checked out in repos:')
        print_bad_repos(remotes_are_current)
        sys.exit(1)

    if unmerged and not feat_args.force and not feat_args.push_only:
        printerr('error: cannot delete unmerged branches (use -D to force) in repos:')
        print_bad_repos(unmerged)
        sys.exit(1)

    deleted_branches_local = 0
    deleted_branches_remote = 0

    del_opt = '-D' if feat_args.force else '-d'
    del_local_cmd = ['git', 'branch', del_opt, '-q', feat_args.name]

    delete_locals = not feat_args.push_only
    delete_remotes = feat_args.push or feat_args.push_only

    local_del_fail = []
    remote_del_fail = []

    if delete_locals:
        for dep, state in exists:
            repo_name = dep.name if dep else 'this repo'
            print('deleting local branch in {0}'.format(repo_name))

            if delete_feature_branch(dep, del_local_cmd, local_del_fail, errs):
                deleted_branches_local += 1

    if delete_remotes:
        for dep, state in has_remote:
            repo_name = dep.name if dep else 'this repo'
            print('deleting remote branch in {0}'.format(repo_name))

            remote = dep.remote if dep else local_config.remote
            push_target = ':{0}'.format(feat_args.name)
            del_remote_cmd = ['git', 'push', '-q', remote, push_target]

            if delete_feature_branch(dep, del_remote_cmd, remote_del_fail, errs):
                deleted_branches_remote += 1

    def print_deletion_summary(
        failures, branch_type, del_count, del_attempt_count):
        print('deleted {0}/{1} {2} branches'.
            format(del_count, del_attempt_count, branch_type))
        if failures:
            printerr("error: couldn't delete branches from:")
        for failure in failures:
            print('  {0}'.format(failure))

    if delete_locals:
        print_deletion_summary(
            local_del_fail, 'local', deleted_branches_local, len(exists))

    if delete_remotes:
        print_deletion_summary(
            remote_del_fail, 'remote', deleted_branches_remote, len(has_remote))

    if errs:
        print_std_err_list(errs)
        sys.exit(1)

def parse_feature_args(args):
    parsed_args = parse_args(args, 'dD', ['push', 'push-only'], usage_fn=print_feature_usage)

    if len(parsed_args[1]) == 0:
        printerr('error: missing feature name')
        print_feature_usage()
        sys.exit(1)

    if len(parsed_args[1]) > 1:
        print_unknown_arg(parsed_args[1][1])
        print_feature_usage()
        sys.exit(1)

    delete = False
    force = False
    push = False
    push_only = False
    for opt, optarg in parsed_args[0]:
        if opt == '-d': delete = True
        if opt == '-D':
            delete = True
            force = True
        if opt == '--push': push = True
        if opt == '--push-only': push_only = True

    feature_name = parsed_args[1][0]

    if push and not delete:
        printerr("error: '--push' can only be used with delete")
        print_feature_usage()
        sys.exit(1)

    if push_only and not delete:
        printerr("error: '--push-only' can only be used with delete")
        print_feature_usage()
        sys.exit(1)

    if push and push_only:
        printerr("error: '--push' and '--push-only' cannot be used together")
        print_feature_usage()
        sys.exit(1)

    return FeatureArgs(feature_name, delete, force, push, push_only)


def print_feature_usage():
    printerr('usage: rept feature <feature-name>')
    printerr('   or: rept feature (-d | -D) [--push | --push-only] <feature-name>')

def cmd_feature(dependencies, local_config, args):
    feat_args = parse_feature_args(args)

    if feat_args.delete:
        delete_feature(dependencies, local_config, feat_args)
    else:
        create_feature(dependencies, feat_args)

################################################################################
# chk-deps cmd funcs
#
# The "chk-deps" command inspects the dependencies for consistency. While the
# .rept_deps files lists all dpendencies directly (there are no implicitly
# inherited dependencies), conflicts are still possible. For instance, two
# dependencies may each depend on different versions of a third dependency.
################################################################################

# Check each dependency for inconsistencies against the target dependencies.
def check_subdeps(dep_chain, dependencies, targets):
    errs = []
    for dep in dependencies:
        dep_abs_path = os.path.abspath(dep.path)
        target_dep = targets.get(dep_abs_path)

        # Because dependencies are flat, the main repo's .rept_deps file must
        # list *all* needed repos all the way down through the dependency tree.
        # So if this dep repo is NOT in the targets, then it's missing from the
        # main .rept_deps file, which is bad.
        if not target_dep:
            err = "Unlisted dependency '{0}' found".format(repo_name)
            errs.append((err, dep_chain))

        # We're requiring that revision names, not just commits have to match.
        # Technically commits are all that are required for consistency, but
        # that's just asking for trouble if we start mixing representations.
        elif dep.revision != target_dep.revision:
            errs.append(
                (['Inconsistent dependency for {0}:'.format(dep.name),
                  'required: {0}'.format(target_dep.revision),
                  'found: {0}'.format(dep.revision)],
                 dep_chain))

        else:
            dep_hash, hash_err = get_rev_hash_from_repo(
                dep.revision, dep_abs_path)
            if not dep_hash:
                err_msg = gen_bad_revision_err_str(
                    dep.name, dep.revision, hash_err)
                errs.append((errs, dep_chain))

            else:
                # If we got here, this dependency's revision is ok. Now gotta
                # check its sub-deps.
                subdep_errs = check_subdeps_for_repo(
                    dep_chain, dep.name, dep_abs_path, targets)
                errs.extend(subdep_errs)

    return errs

# Check the subdependencies for the specified repo against the targets.
def check_subdeps_for_repo(dep_chain, repo_name, repo_abs_path, targets):
    new_dep_chain = dep_chain + [repo_abs_path]

    # If the current repo path is already in the dependency chain, that means
    # we must have a circular dependency, which is bad.
    if repo_abs_path in dep_chain:
        return [('Circular reference detected', new_dep_chain)]

    with DoInExistingDir(repo_abs_path) as ctx:
        if ctx:
            # This is guaranteed to succeed because we verified it in
            # check_subdeps().
            target_dep = targets.get(repo_abs_path)

            # Look for the contents of a .rept_deps file at the specified
            # revision so see if we need to keep doing consistency checks.
            rept_deps_contents = get_file_contents(
                target_dep.revision, '.rept_deps')

            # No .rept_deps file? No prob. Just means no conflicts.
            # Treat an empty file and no file as the same thing.
            if not rept_deps_contents:
                return []

            dependencies, err = parse_dependency_data(rept_deps_contents)

            # If the dependencies couldn't be parsed, we can't continue down
            # this chain, so err out.
            if dependencies == None: # test for None since [] is allowed
                return [(err, new_dep_chain)]

            # Now we can check all of the sub-dependencies of this dependency.
            return check_subdeps(new_dep_chain, dependencies, targets)

        else:
            return [('Missing repo: {0}'.format(repo_name), new_dep_chain)]

def do_check_dep_consistency(dependencies):
    target_deps = {}
    for dep in dependencies:
        repo_path = os.path.abspath(dep.path)
        target_deps[repo_path] = dep

    # Check each dependency for consistency with the targets.
    errs = check_subdeps([os.getcwd()], dependencies, target_deps)

    for err in errs:
        dep_chain = [os.path.basename(dirname) for dirname in err[1]]
        print_std_err(err[0])
        printerr('  Detected in: ' + dep_chain[-1])
        for dep in reversed(dep_chain[:-1]):
            printerr('    included by: ' + dep)

    return not errs

def print_check_dep_usage():
    printerr('usage: rept chk-deps')

def cmd_check_dep(dependencies, args):
    parsed_args = parse_args(args, '', usage_fn=print_check_dep_usage)

    if len(parsed_args[1]):
        print_unknown_arg(parsed_args[1][0])
        print_check_dep_usage()
        sys.exit(1)

    if not do_check_dep_consistency(dependencies):
        sys.exit(1)

################################################################################
# prune cmd funcs
#
# The "prune" command removes all remote branches from all repos on which the
# currently checked out revision of the current repo depend.
# i.e. 'git remote prune <remote>' is called for all dependent repos.
################################################################################

def print_prune_usage():
    printerr('usage: rept prune')

def cmd_prune(dependencies, local_config, args):
    parsed_args = parse_args(args, '', usage_fn=print_prune_usage)

    if len(parsed_args[1]):
        print_unknown_arg(parsed_args[1][0])
        print_prune_usage()
        sys.exit(1)

    errs = []

    print('pruning {0} for this repo...'.format(local_config.remote))
    ret = subprocess.call(['git', 'remote', 'prune', local_config.remote])
    if (ret):
        errs.append(
            "error: cannot prune '{0}' for this repo".format(local_config.remote))

    for dep in dependencies:
        print('pruning {0}...'.format(dep.name))
        with DoInExistingDir(dep.path) as ctx:
            if ctx:
                ret = subprocess.call(['git', 'remote', 'prune', dep.remote])
                if (ret):
                    errs.append(
                        "error: cannot prune repo '{0}': ".format(dep.name))
            else:
                errs.append('Missing repo: {0}'.format(dep.path))

    if errs:
        print_std_err_list(errs)
        sys.exit(1)

################################################################################
# fetch cmd funcs
#
# The "fetch" command fetches all repos on which the currently checked out
# revision of the current repo depend. i.e. 'git fetch <remote>' is called for
# all dependent repos.
################################################################################

def print_fetch_usage():
    printerr('usage: rept fetch')

def cmd_fetch(dependencies, local_config, args):
    parsed_args = parse_args(args, '', usage_fn=print_fetch_usage)

    if len(parsed_args[1]):
        print_unknown_arg(parsed_args[1][0])
        print_fetch_usage()
        sys.exit(1)

    errs = []

    print('fetching {0} for this repo...'.format(local_config.remote))
    ret = subprocess.call(['git', 'fetch', local_config.remote])
    if (ret):
        errs.append(
            "error: cannot fetch '{0}' for this repo".format(local_config.remote))

    for dep in dependencies:
        print('fetching {0}...'.format(dep.name))
        with DoInExistingDir(dep.path) as ctx:
            if ctx:
                ret = subprocess.call(['git', 'fetch', dep.remote])
                if (ret):
                    errs.append(
                        "error: cannot fetch repo '{0}': ".format(dep.name))
            else:
                errs.append('Missing repo: {0}'.format(dep.path))

    if errs:
        print_std_err_list(errs)
        sys.exit(1)

################################################################################
# sync cmd funcs
#
# The "sync" command is used to get all code that the currently checked out
# revision of a repo needs to build. All repos on which the main repo depends
# are pulled fetched or cloned as needed, and the specific revisions of those
# repos are checked out.
################################################################################

def print_sync_usage():
    printerr('usage: rept sync')

def cmd_sync(dependencies, args):
    parsed_args = parse_args(args, '', usage_fn=print_sync_usage)

    if len(parsed_args[1]):
        print_unknown_arg(parsed_args[1][0])
        print_sync_usage()
        sys.exit(1)

    errs = []

    for dep in dependencies:
        repo_path = os.path.abspath(dep.path)

        # If the dir doesn't exist, it needs to. If it does, this is a noop.
        os.makedirs(repo_path, exist_ok=True)

        with DoInExistingDir(repo_path) as ctx:
            if ctx:
                # Empty dir? If so, do a clone.
                if not os.listdir():
                    print('cloning repo {0}...'.format(dep.name))
                    full_remote_repo_name = dep.remote_server + dep.name
                    ret = subprocess.call(
                        ['git', 'clone', '-o', dep.remote,
                         full_remote_repo_name, '.'])
                    if (ret):
                        errs.append(
                            'cannot sync "{0}": '
                            'fetch failed'.format(dep.path))
                # Already a .git dir? If so, do a fetch.
                elif (os.path.isdir('.git')):
                    print('fetching repo {0}...'.format(dep.name))
                    ret = subprocess.call(['git', 'fetch', dep.remote])
                    if (ret):
                        errs.append(
                            'cannot sync "{0}": '
                            'fetch failed'.format(dep.path))
                else:
                    errs.append(
                        'cannot sync {0}: {1} is not empty '
                        'and is not a git repo'.format(
                            dep.name, dep.path))
                # No .git dir. Do a clone.
            else:
                errs.append(
                    'cannot sync {0}: cannot enter directory {1}'.format(
                        dep.name, dep.path))

    if errs:
        printerr('\n{0} errors:'.format(len(errs)))
        for err in errs:
            printerr('- ' + err)
        sys.exit(1)

    if not do_check_dep_consistency(dependencies):
        sys.exit(
            'error: inconsistent dependencies. cannot proceed with checkout')

    for dep in dependencies:
        print('checking out {0} on {1}...'.format(dep.revision, dep.name))
        repo_path = os.path.abspath(dep.path)
        with DoInExistingDir(repo_path) as ctx:
            if ctx:
                ret = subprocess.call(
                    ['git', 'checkout', '-q', dep.revision])
                if ret:
                    errs.append(
                        'cannot check out rev {0} for repo: {1}'.
                            format(dep.revision, dep.path))
            else:
                errs.append(
                    'cannot enter repo at {0} for checkout'.format(dep.path))

    if errs:
        printerr('\n{0} errors:'.format(len(errs)))
        for err in errs:
            printerr('- ' + err)
        sys.exit(1)
    else:
        print('\nSuccess')

################################################################################
# main funcs
################################################################################

def exec_cmd(argv, dependencies, local_config):
    args = argv[1:]

    if argv[0] == 'sync':
        cmd_sync(dependencies, args)
    elif argv[0] == 'fetch':
        cmd_fetch(dependencies, local_config, args)
    elif argv[0] == 'prune':
        cmd_prune(dependencies, local_config, args)
    elif (argv[0] == 'chk-deps' or
          argv[0] == 'cd'):
        cmd_check_dep(dependencies, args)
    elif (argv[0] == 'feature' or
          argv[0] == 'feat'):
        cmd_feature(dependencies, local_config, args)
    elif (argv[0] == 'switch' or
          argv[0] == 'sw'):
        cmd_switch(dependencies, local_config, args)
    else:
        sys.exit('rept: unknown command: {0}'.format(argv[0]))

def main(argv):
    if len(argv) == 0:
        return

    move_to_repo_dir_or_die()

    # Get the dependency file. If we're able to open it, keep it open to lock
    # both it and the directory in which it resides for the duration of
    # execution.
    rept_deps_file = open_rept_dep_file()
    if not rept_deps_file:
        sys.exit('rept: could not find .rept_deps file')
        return

    dependencies = get_dependency_data_or_die(rept_deps_file)

    rept_local_file = open_rept_local_file()
    local_config = get_local_config_or_die(rept_local_file)

    try:
        exec_cmd(argv, dependencies, local_config)
    finally:
        rept_deps_file.close()
        if rept_local_file: rept_local_file.close()

if __name__ == "__main__":
    main(sys.argv[1:])
