#!/usr/bin/env python

import ast
import collections
import os
import subprocess
import sys

Dependency = collections.namedtuple('Dependency',
    'name path remote remote_server revision')
TargetDep = collections.namedtuple('TargetDep',
    'dep full_path rev_hash')

class DoInExistingDir(object):
    def __init__(self, dir):
        self.old_dir = os.getcwd()
        self.new_dir = dir

    def __enter__(self):
        try:
            os.chdir(self.new_dir)
            return self
        except:
            return None

    def __exit__(self, type, value, traceback):
        os.chdir(self.old_dir)
        return isinstance(value, OSError)

################################################################################

def printerr(s):
    print(s, file=sys.stderr)

def print_unkown_param_or_opt(param):
    printerr('error: unknown parameter or option \'{0}\''.format(param))

def get_rev_hash(rev):
    p = subprocess.Popen(
        ['git', 'rev-parse', rev],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    out, err = p.communicate()
    return str(out,'utf-8').strip() if not err else None

def get_rev_hash_from_repo(rev, repo_dir):
    rev_hash = None
    err = ''
    with DoInExistingDir(repo_dir) as ctx:
        if ctx:
            rev_hash = get_rev_hash(rev)
            if not rev_hash:
                err = 'could not get revision from the repo'
        else:
            err = 'could not enter the repo'
    return (rev_hash, err)

def get_branch_exists(branch_name):
    p = subprocess.Popen(
        ['git', 'rev-parse', '--verify', branch_name],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    return p.wait() == 0

def get_any_remote_branch_exists(branch_name):
    p = subprocess.Popen(
        ['git', 'branch', '-a'],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    out, err = p.communicate()

    if err:
        return []

    branches = str(out,'utf-8').strip().split()
    return [branch for branch in branches if
        branch.startswith('remotes/') and branch.endswith('/' + branch_name)]

def find_dep_file(search_up):
    cur_path = os.getcwd()
    file = None
    while not file:
        try:
            file = open(os.path.join(cur_path, '.rept_deps'))
            os.chdir(cur_path)
        except:
            if ((not search_up) or
                (cur_path == os.path.dirname(cur_path))):
                break
            cur_path = os.path.dirname(cur_path)

    return file

def parse_dependency_data(rept_deps_str):
    err = None
    contents = None

    try:
        # Use literal_eval() for safety since we're eval'ing untrusted code.
        contents = ast.literal_eval(rept_deps_str)
    except SyntaxError as e:
        err = 'syntax error at line {0}, offset {1}'.format(e.lineno, e.offset)
        return (None, err)
    except ValueError:
        err = 'illegal value used. (Do you have a function call in the file?)'
        return (None, err)
    except:
        err = 'unknown parse error'
        return (None, err)

    if type(contents) != dict:
        err = 'must contain a single dictionary'
        return (None, err)

    def_remote = ''
    def_remote_server = ''
    def_revision = ''

    defaults = contents.get('defaults')
    if defaults:
        def_remote = defaults.get('remote', def_remote);
        def_remote_server = defaults.get('remote_server', def_remote_server)
        def_revision = defaults.get('revision', def_revision)

    if 'dependencies' not in contents.keys():
        err = '"dependencies" list not found'
        return (None, err)

    dep_list = contents['dependencies']
    if (type(dep_list) != list):
        err = '"dependencies" is not a list'
        return (None, err)

    dependencies = []

    idx = 0
    for dep in dep_list:
        if (type(dep) != dict):
            err = 'dependency {0} is not a dictionary'.format(idx)
            return (None, err)

        name = dep.get('name')
        path = dep.get('path')

        if not name:
            err = 'dependency {0} requires a name'.format(idx)
            return (None, err)

        if not path:
            err = 'dependency {0} requires a path'.format(idx)
            return (None, err)

        remote = dep.get('remote', def_remote)
        remote_server = dep.get('remote_server', def_remote_server)
        revision = dep.get('revision', def_revision)

        if not remote:
            err = 'dependency {0} requires a remote'.format(idx)
            return (None, err)

        if not remote_server:
            err = 'dependency {0} requires a remote server'.format(idx)
            return (None, err)

        if not revision:
            err = 'dependency {0} requires a revision'.format(idx)
            return (None, err)

        dependencies.append(
            Dependency(name, path, remote, remote_server, revision))

        idx += 1

    return (dependencies, err)

def get_dependency_data_from_file(rept_deps_file):
    err = None
    contents = None

    try:
        contents = rept_deps_file.read()
    except:
        err = 'could not read the file'
        return (None, err)

    return parse_dependency_data(contents)

def print_std_err(err):
    if (type(err) == str):
        printerr(err)
    else:
        printerr(err[0])
        for msg in err[1:]:
            printerr('  ' + msg)

def print_std_err_list(errs):
    for err in errs:
        print_std_err(err)

def gen_bad_revision_err_str(dep_name, dep_revision, rev_hash_err):
    return ['Bad revision specified: {0}'.format(dep_revision),
            'for repo: {0}'.format(dep_name),
            rev_hash_err]

################################################################################

def can_create_feature_branch(branch_name, remote_name, dep_name, errs):
    if dep_name:
        err_prefix = 'dependency {0}'.format(dep_name)
    else:
        err_prefix = 'this repo'

    remote_branch_name = remote_name + '/' + branch_name
    if get_branch_exists(branch_name):
        errs.append(
            '{0} already contains a local branch: {1}'.
            format(err_prefix, branch_name))
        return

    if dep_name:
        if get_branch_exists(remote_branch_name):
            errs.append(
                '{0} already contains a remote branch: {1}'.
                format(err_prefix, remote_branch_name))
    else:
        remotes = get_any_remote_branch_exists(branch_name)
        if remotes:
            len_remotes_prefix = len('remotes/')
            remotes = [remote[len_remotes_prefix:] for remote in remotes]
            if len(remotes) == 1:
                errs.append(
                    '{0} already contains a remote branch: {1}'.
                    format(err_prefix, remotes[0]))
            else:
                errs2 = [
                    '{0} already contains remote branches:'.
                    format(err_prefix)]
                errs2 += remotes
                errs.append(errs2)

def cmd_feature(dependencies, argv):
    if (len(argv) == 0):
        sys.exit('rept: missing feature name')

    errs = []
    feature_name = argv[0]

    can_create_feature_branch(feature_name, '', '', errs)

    for dep in dependencies:
        repo_path = os.path.abspath(dep.path)
        remote_branch_name = dep.remote + '/' + feature_name
        with DoInExistingDir(repo_path) as ctx:
            if ctx:
                can_create_feature_branch(feature_name, dep.remote, dep.name, errs)
            else:
                errs.append('Missing repo: {0}'.format(repo_name))
        dep_hash, hash_err = get_rev_hash_from_repo(
            dep.revision, repo_path)
        if not dep_hash:
            errs.append(gen_bad_revision_err_str(
                dep.name, dep.revision, hash_err))

    if errs:
        print_std_err_list(errs)
        sys.exit(1)

    created_branches = 0

    ret = subprocess.call(['git', 'branch', '-q', feature_name])
    if (not ret):
        created_branches += 1
    else:
        errs.append(
            'cannot create branch "{0}" in this repo'.format(feature_name))

    for dep in dependencies:
        repo_path = os.path.abspath(dep.path)
        remote_branch_name = dep.remote + '/' + feature_name
        with DoInExistingDir(repo_path) as ctx:
            if ctx:
                ret = subprocess.call(
                    ['git', 'branch', '-q', feature_name, dep.revision])
                if (not ret):
                    created_branches += 1
                else:
                    errs.append(
                        'cannot create branch "{0}": '
                        'in repo {1}'.format(feature_name, dep.remote))
            else:
                errs.append('Missing repo: {0}'.format(dep.path))

    print('created {0}/{1} branches'.
        format(created_branches, len(dependencies) + 1))

    if errs:
        print_std_err_list(errs)
        sys.exit(1)

################################################################################

def gen_chkdeps_bad_revision_err(dep_name, dep_revision, rev_hash_err, dep_chain):
    errs = gen_bad_revision_err_str(dep_name, dep_revision, rev_hash_err)
    return (errs, dep_chain)

def do_check_subdeps(dep_chain, dependencies, targets):
    errs = []
    for dep in dependencies:
        cur_repo_path = os.path.abspath(dep.path)
        target_for_dep = targets.get(cur_repo_path)
        if target_for_dep:
            dep_hash, hash_err = get_rev_hash_from_repo(
                dep.revision, cur_repo_path)
            if not dep_hash:
                errs.append(gen_chkdeps_bad_revision_err(
                    dep.name, dep.revision, hash_err, dep_chain))
            elif dep_hash != target_for_dep.rev_hash:
                errs.append(
                    (['Inconsistent dependency for {0}:'.format(dep.name),
                      'specified: {0} ({1})'.format(dep.revision, dep_hash),
                      'required: {0} ({1})'.format(
                        target_for_dep.dep.revision, target_for_dep.rev_hash)],
                     dep_chain))
        else:
            errs.extend(
                check_subdeps(dep_chain, dep.name, cur_repo_path, targets))

    return errs

def check_subdeps(dep_chain, repo_name, repo_full_path, targets):
    new_dep_chain = dep_chain + [repo_full_path]

    if repo_full_path in dep_chain:
        return [('Circular reference detected', new_dep_chain)]

    with DoInExistingDir(repo_full_path) as ctx:
        if ctx:
            rept_deps_file = find_dep_file(False)

            # no .rept_deps file? No prob. Just means no conflicts.
            if not rept_deps_file:
                return []

            try:
                dependencies, err = get_dependency_data_from_file(rept_deps_file)
                if dependencies == None: # test for None since [] is allowed
                    return [(err, new_dep_chain)]
                return do_check_subdeps(new_dep_chain, dependencies, targets)
            finally:
                rept_deps_file.close()
        else:
            return [('Missing repo: {0}'.format(repo_name), new_dep_chain)]

def do_check_dep_consistency(dependencies):
    errs = []
    dep_chain_so_far = [os.getcwd()]

    target_list = []
    target_dict = {}
    for dep in dependencies:
        repo_path = os.path.abspath(dep.path)
        target_rev_hash, hash_err = get_rev_hash_from_repo(
            dep.revision, repo_path)
        if target_rev_hash:
            target_dep = TargetDep(dep, repo_path, target_rev_hash)
            target_list.append(target_dep)
            target_dict[repo_path] = target_dep
        else:
            errs.append(gen_chkdeps_bad_revision_err(
                dep.name, dep.revision, hash_err, dep_chain_so_far))

    for target in target_list:
        errs.extend(
            check_subdeps(dep_chain_so_far, dep.name, target.full_path,
                target_dict))

    for err in errs:
        dep_chain = [os.path.basename(dirname) for dirname in err[1]]
        print_std_err(err[0])
        printerr('  Detected in: ' + dep_chain[-1])
        for dep in reversed(dep_chain[:-1]):
            printerr('    included by: ' + dep)

    return not errs

def print_check_dep_usage():
    printerr('usage: rept chk-deps')

def cmd_check_dep(dependencies, params):
    if len(params):
        print_unkown_param_or_opt(params[0])
        print_check_dep_usage()
        sys.exit(1)

    if not do_check_dep_consistency(dependencies):
        sys.exit(1)

################################################################################

def print_fetch_usage():
    printerr('usage: rept fetch')

def cmd_fetch(dependencies, params):
    if len(params):
        print_unkown_param_or_opt(params[0])
        print_fetch_usage()
        sys.exit(1)

    errs = []

    for dep in dependencies:
        print('fetching ' + dep.name + '...')
        with DoInExistingDir(dep.path) as ctx:
            if ctx:
                ret = subprocess.call(['git', 'fetch', dep.remote])
                if (ret):
                    errs.append(
                        'cannot fetch "{0}": '
                        'fetch failed'.format(dep.path))
            else:
                errs.append(
                    'cannot fetch "{0}": '
                    'invalid repo'.format(dep.path))

    if errs:
        print_std_err_list(errs)
        sys.exit(1)

################################################################################

def print_sync_usage():
    printerr('usage: rept sync')

def cmd_sync(dependencies, params):
    if len(params):
        print_unkown_param_or_opt(params[0])
        print_sync_usage()
        sys.exit(1)

    errs = []

    for dep in dependencies:
        print('updating repo {0}...'.format(dep.name))

        repo_path = os.path.abspath(dep.path)

        # If the dir doesn't exist, it needs to. If it does, this is a noop.
        os.makedirs(repo_path, exist_ok=True)

        with DoInExistingDir(repo_path) as ctx:
            if ctx:
                # Already a .git dir? Do a fetch.
                if (os.path.isdir('.git')):
                    ret = subprocess.call(['git', 'fetch', dep.remote])
                    if (ret):
                        errs.append(
                            'cannot sync "{0}": '
                            'fetch failed'.format(dep.path))
                # No .git dir. Do a clone.
                else:
                    full_remote_repo_name = dep.remote_server + dep.name
                    ret = subprocess.call(
                        ['git', 'clone', '-o', dep.remote,
                         full_remote_repo_name, '.'])
                    if (ret):
                        errs.append(
                            'cannot sync "{0}": '
                            'fetch failed'.format(dep.path))
            else:
                errs.append(
                    'cannot sync: cannot enter directory {0}'.format(dep.path))

    if errs:
        printerr('\n{0} errors:'.format(len(errs)))
        for err in errs:
            printerr('- ' + err)
        sys.exit(1)

    if not check_dep_consistency(dependencies):
        sys.exit(
            'error: inconsistent dependencies. cannot proceed with checkout')

    for dep in dependencies:
        print('checking out {0} on {1}...'.format(dep.revision, dep.name))
        repo_path = os.path.abspath(dep.path)
        with DoInExistingDir(repo_path) as ctx:
            if ctx:
                ret = subprocess.call(
                    ['git', 'checkout', '-q', dep.revision])
                if ret:
                    errs.append(
                        'cannot check out rev {0} for repo: {1}'.
                            format(dep.revision, dep.path))
            else:
                errs.append(
                    'cannot enter repo at {0} for checkout'.format(dep.path))

    if errs:
        printerr('\n{0} errors:'.format(len(errs)))
        for err in errs:
            printerr('- ' + err)
        sys.exit(1)
    else:
        print('\nSuccess')

################################################################################

def exec_cmd(argv, dependencies):
    params = argv[1:]

    if argv[0] == 'sync':
        cmd_sync(dependencies, params)
    elif argv[0] == 'fetch':
        cmd_fetch(dependencies, params)
    elif (argv[0] == 'chk-deps' or
          argv[0] == 'cd'):
        cmd_check_dep(dependencies, params)
    elif (argv[0] == 'feature' or
          argv[0] == 'feat'):
        cmd_feature(dependencies, params)
    else:
        sys.exit('rept: unknown command: {0}'.format(argv[0]))

def main(argv):
    if len(argv) == 0:
        return

    # Get the dependency file. If we're able to open it, keep it open to lock
    # both it and the directory in which it resides for the duration of
    # execution.
    rept_deps_file = find_dep_file(True)
    if not rept_deps_file:
        sys.exit('rept: could not find .rept_deps file')
        return

    try:
        dependencies, err = get_dependency_data_from_file(rept_deps_file)
        if not dependencies:
            sys.exit('rept: could not load .rept_deps file: ' + err)
        exec_cmd(argv, dependencies)
    finally:
        rept_deps_file.close()

if __name__ == "__main__":
    main(sys.argv[1:])
